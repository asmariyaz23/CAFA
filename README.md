CAFA Benchmark Assessment and Target Generation Program

This dual mode tool can be used both for the generation of protein targets that users could predict function on
and also for the generation of benchmarks that will be used further down to assess user's predictions.

Though the idea stemmed from the existence of the CAFA competition, the tool has been developed in as much of a
generalized fashion as possible. So, it can be used by both CAFA and non-CAFA particpants for assessing their function
prediction methods.

Usage:

python Benchmark --input1 \<t1 uniprot-goa filename/time point t1\> --input2 \<t2 uniprot-goa filename/time point t2\>

This is the most basic version of running the benchmark program that will generate a list of proteins that were
electronically annotated in t1 file and gained experimenatl evidence in t2 file.

This result can be filtered using a bunch of optional parameters and the entire list can be obtained by typing

python Benchmark --help

This is the default mode of running the program. The other mode is the target generation mode which can be used by adding
the -M switch to the Benchmark program

python Benchmark -M TG --input1 \<uniprot-goa gaf file\> --input2 \<uniprot-goa gpi file\>

When run in the above specified way, the program will filter all swiss prot protein in the gaf file, that are in the 
current gaf file electronically annotated and have the potential of becoming a candidate benchmark in the future. The gpi
file is used to obtain information as to which proteins belong to Swiss-Prot.

This mode only has 1 optional parameter, -Y or targetType. This switch provides user an option to specify what kind of
targets they would like to include. In the default case, the targetType is set to '0'. This means all proteins that are
exclusively electronically annotated (in a given ontology) in the current uniprot-goa gaf file will only be considered
as being a target protein. The other value for targetType is '1'. This means even proteins that currently have some 
experimental evidence associated with them could also be considered as target, in the hope that the protein might gain
additional function in the future.

There is a config file associated with the program called .cafarc. This file lists the pathnames and pre-defined values
for some variables. This is the first file that a user of this program should open and go through. Most values are good
being kept at default. The one thing that users should consider changing is the name of their working directory. In the
default mode, it will be kept as the current directory. So all result files will be stored in the current directory. But
a user can change this and provide a separate directory name. In that case, all files resulting will be stored in the 
directory specified by the user.

Output:

The Target Generation mode of the program outputs a single fasta file. This contains the sequences of all the target
proteins generated by the program. The header of each sequence will contain a CAFA specific ID and the original Swiss-
Prot id of the protein.

The Benchmark Creation mode outputs 3 files. The first file is a tab delimited file that lists all the benchmark proteins.
This file has 4 columns in the following order : Uniprot ID, Ontology, GO Term and either 'N' or 'O' depending on whether
the annotation is novel or if it was present from before. The second file is a .png file describing the distribution of
the benchmark proteins with respect to ontology. This bar plot gives users an idea as to how many proteins belong to a
particular ontology. This might help remove potential bias in the benchmark data. The third file is a fasta file
containing sequence information for the benchmark proteins. This file is created based on user's choice. When the number
of benchmark proteins is above 500, the program will ask the user if they want to download the sequence information or
not, since downloading too many sequences using Uniprot api takes some time.

Sample use cases:

A bunch of sample use cases have been mentioned in the file "queries.txt". This will help provide users with an idea of
how to use the program and what kind of output to expect. But just keep in mind, the use cases are just 1 out of many
possible ways that the program can be run. So, feel free to explore with all the availble options.

Source Code :

The source code is publicly available on github through the following url : https://github.com/rajeswari284/CAFA
This is an open source project. So, please feel free to contribute. In case of any questions or comments regarding the 
code, please email to any of the following :

idoerg@gmail.com
rajeswari284@gmail.com

